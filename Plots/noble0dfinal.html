---
title: Noble0d Other
plot: true
---
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Noble Model</title>
	<link href="../node_modules/plotter/plotter.css" type="text/css" rel="stylesheet" />
	<script src="../node_modules/plotter/plotter.js"></script>
	<script>


		//% Noble model in 0d

		//% parameter values
		//cm=12;          % membrane capacitance
		//% vary gan e.g. 0, 0.075, 0.18, 0.4
		//gan=0.0;         % conductance of leak current; higher values promote auto-oscillation
		// ean=-60;        % leak current reversal potential

		//% stimulus (this will be a periodic square pulse)
		//% threshold is about -53; double this
		// stimmag=-106;   % magnitude of stimulus in units of current (\muA?)
		// stimdur=2.0;    % duration of stimulus in ms
		// period=500.0;   % period of stimulus in ms (270 shows alternans, 500 does not)
		// % note that slowing the period too much will allow the cell to stimulate 
		// % itself without an external stimulus, although it still can respond to it

		// % initial values 
		// v = -80.0;      % initial value of membrane potential in mV
		// m = 0.0;        % initial value of m-gate (sodium activation gate)
		// h = 1.0;        % initial value of h-gate (sodium inactivation gate)
		// n = 0.0;        % initial value of n-gate (potassium activation gate)

		// % numerical parameters
		// dt = 0.01;      % time step in ms
		// endtime = 5000; % duration of simulation in ms
		// nsteps=ceil(endtime/dt);    % number of time steps for whole simulation

		// % vectors for saving data to plot
		// vsave = zeros(nsteps+1,1);
		// msave = zeros(nsteps+1,1);
		// hsave = zeros(nsteps+1,1);
		// nsave = zeros(nsteps+1,1);
		// vsave(1,1) = v;
		// msave(1,1) = m;
		// hsave(1,1) = h;
		// nsave(1,1) = n;

		// ina1save = zeros(nsteps+1,1);
		// ina2save = zeros(nsteps+1,1);
		// ik1save = zeros(nsteps+1,1);
		// ik2save = zeros(nsteps+1,1);
		// ilsave = zeros(nsteps+1,1);
		// inasave(1,1) = 0;
		// iksave(1,1) = 0;
		// ilsave(1,1) = 0;
		// t = 0:dt:endtime;       % time vector

		// for ntime=0:nsteps-1

		//     % calculate alphas and betas for updating gating variables
		//     if(abs(-v-48)<1e-3)
		//         am=0.15;
		//     else
		//         am=0.1*(-v-48)./(exp((-v-48)/15)-1);
		//     end
		//     
		//     if(abs(v+8)<1e-3)
		//         bm=0.6;
		//     else
		//         bm=0.12*(v+8)./(exp((v+8)/5)-1);
		//     end

		    
		//     ah=0.17*exp((-v-90)/20);
		//     bh=1./(exp((-v-42)/10)+1);
		//     if(abs(-v-50)<1e-3)
		//         an=0.001;
		//     else
		//         an=0.0001*(-v-50)./(exp((-v-50)/10)-1);
		//     end
		//     bn=0.002*exp((-v-90)/80);

		//     % calculate derivatives of gating variables
		//     dm=am*(1-m)-bm*m;
		//     dh=ah*(1-h)-bh*h;
		//     dn=an*(1-n)-bn*n;

		//     % update gating variables using explicit method
		//     m = m + dt*dm;
		//     h = h + dt*dh;
		//     n = n + dt*dn;
		//     % semi-implicit
		//     % m=(m+dt*am)/(1+dt*(am+bm));
		//     % h=(h+dt*ah)/(1+dt*(ah+bh));
		//     % n=(n+dt*an)/(1+dt*(an+bn));

		//     % calculate potassium current conductance values
		//     gk1 = 1.2*exp((-v-90)/50)+0.015*exp((v+90)/60);
		//     gk2 = 1.2*n.*n.*n.*n;

		//     % calculate currents
		//     ina1=400*m.*m.*m.*h.*(v-40);
		//     % ina2=0.13*(v-40); % this makes it not auto-oscillatory
		//     ina2=0.14.*(v-40);
		//     ik1=gk1.*(v+100);
		//     ik2=gk2.*(v+100);
		//     il=gan*(v-ean);

		//     % sum the two sodium and the two potassium currents
		//     ina=ina1+ina2;
		//     ik=ik1+ik2;

		//     % set stimulus current periodically to be nonzero
		//     istim=0;
		//     if(mod(ntime,round(period/dt))<round(stimdur/dt))
		//         istim=stimmag;
		//     end

		//     % calculate derivative of voltage 
		//     dv=(-ina-ik-il-istim)/cm;

		//     % update voltage using forward Euler
		//     v = v + dt*dv;

		//     % save voltage, gating variables, and currents for plotting
		//     % note that we update location ntime+2, because the loop starts at
		//     % index 0 and we also save one initial value outside the loop, and
		//     % Matlab starts indexing at 1
		//     vsave(ntime+2,1) = v;
		//     msave(ntime+2,1) = m;
		//     hsave(ntime+2,1) = h;
		//     nsave(ntime+2,1) = n;

		//     ina1save(ntime+2,1) = ina1;
		//     ina2save(ntime+2,1) = ina2;
		//     ik1save(ntime+2,1) = ik1;
		//     ik2save(ntime+2,1) = ik2;
		//     ilsave(ntime+2,1) = il;

		// end

		// % plot the voltage in top subplot and the three gating variables below
		// figure(1)
		// subplot(2,1,1)
		// plot(t,vsave,'k','linewidth',2)
		// ylabel('V_m')
		// subplot(2,1,2)
		// plot(t,msave,'b',t,hsave,'g',t,nsave,'r','linewidth',2)
		// xlabel('Time')
		// legend('m','h','n')
		// legend boxoff

		// % plot the currents in a separate plot
		// figure(2)
		// plot(t,ina1save,'r',t,ina2save,'g',t,ik1save,'b',t,ik2save,'c',t,ilsave,'m','linewidth',2)
		// xlabel('Time')
		// legend('I_{Na1}','I_{Na2}','I_{K1}','I_{K2}','I_l')
		// legend boxoff

		var app;

		/**
		 * These are default values. These are the values that will be used
		 * when the plots are loaded and they will be used to reinitialize
		 * the plots if the user specifies.
		 */
		var defaultV = -80.0;
		var defaultM = 0.0;
		var defaultH = 1.0;
		var defaultN = 0.0;

		/**
		 * These are variables that can be modified by user input. They are 
		 * used in the calculation of the values that will be plotted.
		 */
		var cm= 12;
		var gan = 0.0;
		var ean= -60;
		var stimmag= -106;
		var stimdur= 2.0;
		var period=500.0;

		var v = defaultV; 
		var m = defaultM;
		var h = defaultH;
		var n = defaultN;


		/**
		 * These control how how often points are graphed. The time and the 
		 * timestep should remain constant. At each step, the function performs
		 * a batch of calculations and records the final result. The size of
		 * each batch is determined by the batchSize variable.
		 */
		var time = 5000;
		var timestep = 0.01;
		var batchSize = 50;
		var stepSize = batchSize * timestep;
		var steps = (time / stepSize);


		/**
		 * These hold the values that will be plotted. They are updated every
		 * time calculate() is called.
		 */
		var vArray = [];
		var mArray = [];
		var hArray = [];
		var nArray = [];
		var count = 0;



		/**
		 * creates the plotter object and defines all of the plots to be
		 * displayed.
		 */
		function buildGraphs() {
			app = createPlotter(document.getElementById("plot"));

			// app.newPlot({
			// 	domain: new Point(0, 5000),
			// 	range: new Point(0, 1),
			// 	unitPerTick: new Point(500, 1),
			// 	pixelPerUnit: new Point(.1, 400),
			// 	labelFrequency: new Point(1, 1),
			// 	xAxis: "Time (ms)",
			// 	yAxis: "V (mv)",

			// }, "Noble");

			// app.newPlot({
			// 	domain: new Point(0, time),
			// 	range: new Point(-100, 100),
			// 	unitPerTick: new Point(1000, 50),
			// 	pixelPerUnit: new Point(.1, 2),
			// 	labelFrequency: new Point(1, 1),
			// 	xAxis: "Time (ms)",
			// 	yAxis: "V (mv)",

			// }, "Noble");

			app.newPlot({
				domain: new Point(0, time),
				range: new Point(0, 1),
				unitPerTick: new Point(1000, .1),
				pixelPerUnit: new Point(.1, 500),
				labelFrequency: new Point(1, 1),
				xAxis: "Time (ms)",
				yAxis: "V (mv)",

			}, "Noble");
		}


		/** 
		 * Set up the form so that the graph can respond to user input.
		 */
		function buildForms() {
			document.getElementById("update").onclick = resetGraph;
			document.getElementById("default").onclick = setDefaults;

			document.getElementById("displayVm").onclick = resetGraph;
			document.getElementById("displayV").onclick = resetGraph;
			document.getElementById("getData").onclick = printData;
		}


		/**
		 * Calculate the values that will be plotted. This is a differential 
		 * equation, so the values compound on each other. The values are 
		 * stored in 4 different arrays. The calculation is divided into steps.
		 * At each step, the function runs a batch of calculations. Once this
		 * batch is complete, the values are stored in the arrays.
		 * @return {[type]} [description]
		 */
		var calculate = function() {
			vArray = [];
			mArray = [];
			hArray = [];
			nArray = [];
			var count = 0;
			for (var j = 0; j < steps; j++) {	
				var vVal = v;
				var mVal = m;
				var hVal = h;
				var nVal = n;
				for (var i = 0; i < batchSize; i++) {


					// calculate alphas and betas for updating gating variables
				 	var am;
				    if (Math.abs(-v - 48) < 0.001) {
				    	am=0.15;
				    } else {
				    	am=0.1*(-v-48)/(Math.exp((-v-48)/15)-1);
				    }
					var bm;
					if (Math.abs(v + 8) < 0.001) {
						bm = 0.6;
					}
					else {
						bm=0.12*(v+8)/(Math.exp((v+8)/5)-1);
					}
					var ah = 0.17 * Math.exp((-v - 90)/20);
					var bh = 1 / (Math.exp((-v - 42)/10) + 1);
					var an;
					if (Math.abs(-v - 50) < 0.001) {
						an = 0.001;
					} else {
						an = 0.0001 * (-v - 50) / (Math.exp((-v-50)/10)-1);
					}
					var bn = 0.002 * Math.exp((-v-90)/80);


					// calculate derivatives of gating variables
					var dm = am * (1-m) - bm * m;
					var dh = ah * (1-h) - bh * h;
					var dn = an * (1-n) - bn * n;


					// update gating variables using explicit method
					m += timestep * dm;
					h += timestep * dh;
					n += timestep * dn;

					// calculate potassium current conductance values
					var gk1 = 1.2 * Math.exp((-v-90)/50) + 0.015 * Math.exp((v+90)/60);
					var gk2 = 1.2 * Math.pow(n, 4);


					// calculate currents
					var ina1 = 400 * m * m * m * h * (v - 40);
					var ina2 = 0.14 * (v - 40);
					var ik1 = gk1 * (v + 100);
					var ik2 = gk2 * (v + 100);
					var il = gan * (v - ean);


					// sum the two sodium and the two potassium currents
					var ina = ina1 + ina2;
					var ik = ik1 + ik2;


					// set stimulus current periodically to be nonzero
					var istim = 0;
					if (count % round(period/timestep) < round(stimdur / timestep)) {
						istim = stimmag
					}


					// calculate derivative of voltage 
					var dv = (-ina - ik - il - istim) / cm;


					// update voltage using forward Euler
					v += timestep * dv;
					count++;
			    }
			    vArray.push(normalize(vVal, new Point(-80, 40)));
			    mArray.push(mVal);
			    hArray.push(hVal);
			    nArray.push(nVal);	
			}
		}


		/**
		 * Draw the plots according to the data specified in the arrays
		 */
		//var count = 0;
		function update() {

			app.selectPlot("Noble");
			app.ctx.strokeStyle = "#FF0000";
			app.ctx.lineWidth = 3;
			app.plotFunction(function(x) {
				var index = Math.round(x / stepSize);
				return vArray[index];
			}, true, stepSize, 0, time);

			app.ctx.strokeStyle = "#00FF00";
			app.ctx.lineWidth = 3;
			app.plotFunction(function(x) {
				var index = Math.round(x / stepSize);
				return mArray[index];
			}, true, stepSize, 0, time);

			app.ctx.strokeStyle = "#0000FF";
			app.ctx.lineWidth = 3;
			app.plotFunction(function(x) {
				var index = Math.round(x / stepSize);
				return hArray[index];
			}, true, stepSize, 0, time);

			app.ctx.strokeStyle = "#FF00FF";
			app.ctx.lineWidth = 3;
			app.plotFunction(function(x) {
				var index = Math.round(x / stepSize);
				return nArray[index];
			}, true, stepSize, 0, time);

			requestAnimationFrame(update);

			// app.plot(Noble, "v", {
			// 	normalize: new Point(-85, -75),
			// 	connected: true,
			// 	radius: 0,
			// 	strokeStyle: "green"
			// });

			// app.plot(Noble, "h", {
			// 	normalize: new Point(0, 1),
			// 	connected: true,
			// 	radius: 0,
			// 	strokeStyle: "red"
			// });	
		}


		/**
		 * print the data from plotter.
		 */
		function printData() {
			app.printPlotData(Noble);
			//window.open("data:text/csv;charset=utf-8," + encodeURIComponent(csv));
		}

		/**
		 * Reset the graph with the given form values
		 */
		function resetGraph() {
			vstar = numericValue(document.getElementsByName("vstar")[0].value);
			xm = numericValue(document.getElementsByName("xm")[0].value);
			ueps = numericValue(document.getElementsByName("ueps")[0].value);
			eps = 1/ueps;
			s1 = numericValue(document.getElementsByName("s1")[0].value);
			s2 = numericValue(document.getElementsByName("s2")[0].value);
			time = numericValue(document.getElementsByName("time")[0].value);

			displayVm = document.getElementsByName("displayVm")[0].checked;
			displayV = document.getElementsByName("displayV")[0].checked;

			Karma.voltage = 0.0;
			Karma.vgate = 0.0;
			Karma.points = [];

			update();
		}

		/** 
		 * Reset the form with the default values
		 */
		function setDefaults() {
			ueps = 250.0;
			eps = 1.0 / ueps;
			xm = 10.0;
			vstar = 0.64;
			s1 = 0.0;						// the first point to introduce voltage
			s2 = 300.0;						// the second point to introduce voltage
			time = 500.0;					// the time over which we view the function
			previousHeaviside = 0;
			currentHeaviside = 0;

			timestep = .25;					// dt - this should be covered by x
			startTime = 0;

			curTime = 0.0;					// t - this should be covered by x
			voltage = 0.0;					// Vm - the Voltage in the cell 
			vgate = 0.0;

			// update the form to reflect the changes
			document.getElementsByName("vstar")[0].value = vstar;
			document.getElementsByName("xm")[0].value = xm;
			document.getElementsByName("ueps")[0].value = ueps;
			document.getElementsByName("s1")[0].value = s1;
			document.getElementsByName("s2")[0].value = s2;
			document.getElementsByName("time")[0].value = time;

			app.clearPlot();
			update();
		}

		function refitPlot() {
			// app.editPlot("Noble",
			// {
			// 	domain: new Point(0, time),
			// 	pixelPerUnit: new Point(1/(time/500), 100)
			// },
			// true,
			// true);
		}


		/**
		 * When the window loads, initialize out graph and plot the data.
		 */
		window.onload = function() {
			buildGraphs();
		 	buildForms();
		 	calculate();
			requestAnimationFrame(update);
		}



		// UTILITY FUNCTIONS
		/**
		 * The heaviside function. Return 0 if the expression is negative
		 * and 1 otherwise
		 * @param  {int} expression The expression to evaluate
		 * @return {int} 0 if the expression evaluates to a negative number, 1 otherwise
		 */
		function heaviside(expression) {
			if (expression < 0) {
				return 0;
			} else {
				return 1;
			}
		}


		/** 
		 * A rounding function that more closely resembles Matlab's round() 
		 * function.
		 * http://www.mathworks.com/help/matlab/ref/round.html
		 */
		function round(val) {
			if (val > 0) {
				return Math.round(val);
			} else if (val < 0) {
				var abs = Math.abs(val);
				var round = Math.round(abs);
				return -round;
			} else {
				return 0;
			}
		}


		/**
		 * Return the numeric value of the input if it has one. If the value
		 * is not a number, return zero.
		 * 
		 * @param  {any} value - can be any value. The function will interpret
		 * non-numeric values as zero.
		 * 
		 * @return {number} - the numeric value of the input if it exists. Zero
		 * otherwise
		 */
		function numericValue(value) {
			if (!isNaN(Number(value))) {
				return Number(value);
			} else {
				return 0;
			}
		}


		/**
		 * Return the normalized value as it exists within the range.
		 * 
		 * @param  {number} value - the value to be normalized.
		 * 
		 * @param  {Point} range - a Point that defines the upper and lower
		 * bounds of the normalization. the x value is the minimum value, while
		 * the y value is the maximum.
		 * 
		 * @return {number} - The normalized value. It is expressed as a number
		 * between 0 and 1.
		 */
		function normalize(value, range) {
			var norm = (value - range.x)/(range.y - range.x);
			return norm;
		}

		/**
		 * An object that contains references to the different colors used by the
		 * graph.
		 */
		var Colors {
			Aqua: "rgb(29, 239, 242)",
			Yellow: "rgb(254, 238, 0)",
			Black: "rgb(0, 0, 0)",
			Indigo: "rgb(47, 38, 224)",
			YellowGreen: "rgb(155, 226, 17)",
			Purple: "rgb(175, 26, 235)",
			Pink: "rgb(255, 153, 255)",
			Gray: "rgb(102, 102, 102)",
			Orange: "rgb(255, 153, 0)",
			LightBlue: "rgb(0, 153, 255)",
			Red: "rgb(255, 0, 0)",
			Green: "rgb(19, 171, 19)",
		}


	</script>
	</style>
</head>
<body>
	<div id="app">
		<canvas id="plot">hello</canvas>
	</div>
	<div id="controls" class="plotter_form">

		<!-- Formulas -->
<!-- 		<fieldset>
			<legend>Formulas</legend>
			<span><strong>Vm:</strong> -Vm + [gamma - (v/v*)<sup>xm</sup>] * h(Vm)</span><br />
			<span><strong>h(Vm)</strong>: [Vm<sup>2</sup> - (delta * Vm<sup>3</sup>)]/alpha</span><br />
			<span><strong>V:</strong> epsilon(Theta(Vm - 1) - v)</span><br />
		</fieldset> -->

		<!-- inputs -->
		<fieldset>
			<div class="plotter_inputgroup plotter_inputgroup-green">
				<input id="displayV" name="displayV" type="checkbox" checked/>
				<label for="displayV">Display V</label>
			</div>
			<div class="plotter_inputgroup plotter_inputgroup-red">
				<input id="displayVm" name="displayVm" type="checkbox" checked/>
				<label for="displayVm">Display Vm</label>
			</div>
		</fieldset>
		<fieldset>
			<div class="plotter_inputgroup">
				<label for="vstar">VStar</label>
				<input type="text" name="vstar" value="0.64" />
			</div>
			<div class="plotter_inputgroup">
				<label for="xm">xm</label>
				<input type="text" name="xm" value="10.0" />
			</div>
			<div class="plotter_inputgroup">
				<label for="ueps">1/eps</label>
				<input type="text" name="ueps" value="250" />
			</div>
			<div class="plotter_inputgroup">
				<label for="s1">S1</label>
				<input type="text" name="s1" value="0.0"/>
			</div>
			<div class="plotter_inputgroup">
				<label for="s2">S2</label>
				<input type="text" name="s2" value="300.0" />
			</div>
			<div class="plotter_inputgroup">
				<label for="time">time</label>
				<input type="text" name="time" value="500.0" />
			</div>
		</fieldset>

		<!-- Buttons -->
		<fieldset>
			<div class="plotter_inputgroup">
				<button id="update">Update</button>
				<button id="default">Defaults</button>
				<button id="getData">Print Data</button>
			</div>
		</fieldset>
	</div>
</body>
</html>